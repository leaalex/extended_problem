<p><strong>Пример 1.</strong> Рассмотрим граф, представленный на рисунке 1.</p>

<figure style="text-align:center;">
  <img src="/static/SYSANALYSIS_R_02_02_img_01.png" alt="" style="max-width: 600px;"/>
  <figcaption>Рис.1. Условие примера 1</figcaption>
</figure>
<p></p>

<p>Необходимо задать условие кодом на языке программирования Python и найти кратчайший путь используя алгоритм Дейкстры от вершины 1 до вершины 10 и его длину.</p>
<p><strong>Решение</strong></p>
<p>Можно использовать библиотеку <code class="inline">Networkx</code> в среде Google Colab. Для этого создать в Google Colab новый проект и добавить в него приведенный ниже код. В первую ячейку вставить код для установки библиотеки:</p>
<pre><code>!pip install networkx
import networkx as nx</code></pre>

<p>Во вторую ячейку нужно добавить код:</p>

<pre><code># Описания графа
edges = [
    (1, 2, {"weight": 1}),
    (1, 4, {"weight": 10}),
    (1, 6, {"weight": 6}),
    (1, 8, {"weight": 3}),
    (2, 3, {"weight": 9}),
    (2, 4, {"weight": 8}),
    (3, 4, {"weight": 1}),
    (3, 5, {"weight": 2}),
    (3, 10,{"weight": 7}),
    (4, 5, {"weight": 4}),
    (4, 6, {"weight": 3}),
    (4, 7, {"weight": 1}),
    (5, 7, {"weight": 5}),
    (5, 10,{"weight": 2}),
    (6, 7, {"weight": 3}),
    (6, 8, {"weight": 2}),
    (7, 8, {"weight": 6}),
    (7, 9, {"weight": 3}),
    (7, 10,{"weight": 7}),
    (8, 9, {"weight": 8}),
    (9, 10,{"weight": 5}),
]

G = nx.Graph() # Создает неориентированный граф
for i in range(1, 11):  # Добавим узлы от 1 до 10 включительно
    G.add_node(i)
G.add_edges_from(edges)

pos = nx.planar_layout(G)

print(G) # Эта команда покажет количество вершин и ребер

nx.draw_circular(G, with_labels = True) # Нарисует график с круговой компоновкой, а ребра можно будет отметить с помощью nx.draw_networkx_edge_labels()

# Это задаст кратчайший путь от узла 1 до узла 10
p1to10 = nx.shortest_path(G, source=1, target=10, weight="weight")

#  Это даст вычислить длину кратчайшего пути от узла 1 до узла 10
length = nx.shortest_path_length(G, source=1, target=10, weight="weight")

#  Выведем порядок обхода вершин
print("Кратчайший путь от 1 до 10: ", p1to10)

#  Выведем длину пути
print("Длина кратчайшего пути: ", length)</code></pre>
<p> </p>
<p>Затем нужно запустить ячейки с кодом на выполнение или нажать <code class="inline">Ctrl+9</code>. Под ячейками с кодом появится количество вершин и ребер, порядок обхода вершин и длина кратчайшего пути, схематическое изображение графа.</p>

<p><strong><strong>Пример 2. </strong></strong>Применим алгоритм поиска в глубину для графа, изображенного на рисунке 1.</p>

<figure style="text-align:center;">
  <img src="/static/SYSANALYSIS_R_02_02_img_02.png" alt="" style="max-width: 600px;"/>
  <figcaption>Рис.2. Условие примера 2</figcaption>
</figure>
<p></p>

<p>Необходимо задать условие кодом на языке программирования Python и записать порядок обхода вершин, используя алгоритм поиска в глубину.</p>
<p> <strong>Решение</strong></p>
<p>Создадим в Google Colab новый проект и добавить в него приведенный ниже код. В первую ячейку вставить код для описания графа:</p>

<pre><code># Инициализация графа
graph = {'A': ['D', 'G'],
         'D': ['A', 'E','B'],
         'E': [ 'D', 'H'],
         'B': ['D'],
         'H': ['E','I'],
         'I': ['H'],
         'G': ['A', 'J'],
         'J': ['C','G','F'],
         'F': ['J','K'],
         'K': ['F'],
         'C': ['J']}

 # Реализуем алгоритм поиска в глубину
def dfs(graph, start):
    visited, stack = [], [start]
    while stack:
        vertex = stack.pop()
        if vertex not in visited:
            visited.append(vertex)
            stack.extend(set(graph[vertex]) - set(visited))
    return visited

# Выводим результат поиска
print(dfs(graph, 'A')) # Указываем начальную вершину</code></pre>

<p>Затем нужно запустить ячейки с кодом на выполнение или нажать <code class="inline">Ctrl+9</code>. Под ячейками с кодом появится набор вершин в том порядке, который будет получен после использования алгоритма.</p>

<p><strong>Решение</strong></p>
<p>Создадим в Google Colab новый проект и добавить в него приведенный ниже код. В первую ячейку вставить код для описания графа: </p>

<pre><code># Инициализация графа
graph = {'A': ['D', 'G'],
         'D': ['A', 'E','B'],
         'E': ['D', 'H'],
         'B': ['D'],
         'H': ['E','I'],
         'I': ['H'],
         'G': ['A', 'J'],
         'J': ['C','G','F'],
         'F': ['J','K'],
         'K': ['F'],
         'C': ['J']}

# Реализуем алгоритм поиска в глубину
def dfs(graph, start):
    visited, stack = [], [start]
    while stack:
        vertex = stack.pop()
        if vertex not in visited:
            visited.append(vertex)
            stack.extend(set(graph[vertex]) - set(visited))
    return visited

# Выводим результат поиска
print(dfs(graph, 'A')) # Указываем начальную вершину</code></pre>

<p>Затем нужно запустить ячейки с кодом на выполнение или нажать <code class="inline">Ctrl+9</code>. Под ячейками с кодом появится набор вершин в том порядке, который будет получен после использования алгоритма.</p>
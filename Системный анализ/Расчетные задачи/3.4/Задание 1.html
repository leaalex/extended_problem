<problem>
  <style type="text/css">

    .drag-custom-oCcuAXGZRe{
      word-break: initial;
      display: flex;
      border: 1px solid #FFCE6D;
      color: #4B5F81;
      text-align: left;

      border-radius: 4px;
      padding: 0px !important;
      line-height: 1.1 !important;
    }
    .drop-custom-oCcuAXGZRe{
      display: flex;
      align-items: center;
      flex-direction: column;
      justify-content: center;
      /*background: #eee !important;*/
      background: #fff !important;
      border: 1px solid #FFCE6D;
      border-radius: 4px;
    }

    .custom-drag-zone-oCcuAXGZRe .drag-zone{
      background: #3e607a0f !important;

    }

    .drop-custom-oCcuAXGZRe.font-size-14px .drag-custom-oCcuAXGZRe{
      border: none !important;
      text-align: center !important;
      justify-content: center;
      display: flex;
      align-items: center;
    }

    .drag-element-image img{
      width: 100%;
    }

  </style>
  <div>
    <p><strong>Цель:</strong> строить BPMN-диаграммы по заданному описанию.</p>
    <p><strong>Задача.</strong> Составить BPMN-диаграмму для заданного описания процесса детектирования дефектов электросетевого оборудования.</p>
    <p>В программное обеспечение для детектирования дефектов силового трансформатора приходят сигналы от системы мониторинга, содержащие данные о концентрациях растворенных в трансформаторном масле газов. Они поступают на вход алгоритма оценки состояния оборудования по данным газосодержания. Если алгоритм выдает сигнал о потенциальном дефекте, то в зависимости от наличия дополнительных диагностических данных выполняется анализ результатов проведенного ранее тепловизионного (инфракрасного) контроля (ИК-контроля) и/или анализ данных диагностических испытаний обмоток трансформатора. Если по итогам проверок подтверждается наличие дефекта, то генерируется предупреждение. Кроме того, независимо от результатов диагностики они сохраняются в базе данных. </p>
    <p>Необходимо построить BPMN-диаграмму и заполнить пропуски в схеме, приведенной ниже.</p>

    <div data-type="DragAndDropVueApp" class="adv-app" data-initial-data="$student_data"/>
    <div style="display: none !important;">
      <customresponse cfn="check_answer">
        <textline size="100"/>
        <br/>
      </customresponse>
    </div>
    <solution data-initial-data="$correct_data"/>
  </div>
  <script type="loncapa/python">
# -*- coding: utf-8 -*-
import random
import json
import string


def generate_id(length=8):
    return 'id_' + ''.join(random.sample(string.ascii_lowercase + string.ascii_uppercase + string.digits, length))


source_data = {
    "background_src": "/static/SYSANALYSIS_R_03_04_task_img_01.png",
    "width": 800,
    "height": 315,
    "drag_class": "drag-custom-oCcuAXGZRe",
    "drop_class": " drop-custom-oCcuAXGZRe animate",
    "drop_zone_class": "center",
    "drag_zone_class": "custom-drag-zone-oCcuAXGZRe",
    "answers": [
        {
            "coordinates": {"x": 7, "y": 129, "w": 67, "h": 60},
            "content": [{"image": "/static/SYSANALYSIS_R_03_04_task_img_02.png", "w": 67, "h": 60}],
            "class": "drag-custom-oCcuAXGZRe",
            "hint": "",
        },
        {
            "coordinates": {"x": 99, "y": 129, "w": 67, "h": 60},
            "content": [{"image": "/static/SYSANALYSIS_R_03_04_task_img_03.png", "w": 67, "h": 60}],
            "class": "drag-custom-oCcuAXGZRe",
            "hint": "",
        },
        {
            "coordinates": {"x": 193, "y": 129, "w": 67, "h": 60},
            "content": [{"image": "/static/SYSANALYSIS_R_03_04_task_img_04.png", "w": 67, "h": 60}],
            "class": "drag-custom-oCcuAXGZRe",
            "hint": "",
        },
        {
            "coordinates": {"x": 261, "y": 43, "w": 67, "h": 60},
            "content": [{"image": "/static/SYSANALYSIS_R_03_04_task_img_05.png", "w": 67, "h": 60}],
            "class": "drag-custom-oCcuAXGZRe",
            "hint": "",
        },
        {
            "coordinates": {"x": 447, "y": 43, "w": 67, "h": 60},
            "content": [{"image": "/static/SYSANALYSIS_R_03_04_task_img_06.png", "w": 67, "h": 60}],
            "class": "drag-custom-oCcuAXGZRe",
            "hint": "",
        },
        {
            "coordinates": {"x": 631, "y": 43, "w": 67, "h": 60},
            "content": [{"image": "/static/SYSANALYSIS_R_03_04_task_img_07.png", "w": 67, "h": 60}],
            "class": "drag-custom-oCcuAXGZRe",
            "hint": "",
        },
        {
            "coordinates": {"x": 631, "y": 129, "w": 67, "h": 60},
            "content": [{"image": "/static/SYSANALYSIS_R_03_04_task_img_08.png", "w": 67, "h": 60}],
            "class": "drag-custom-oCcuAXGZRe",
            "hint": "",
        },
        {
            "coordinates": {"x": 631, "y": 216, "w": 67, "h": 60},
            "content": [{"image": "/static/SYSANALYSIS_R_03_04_task_img_09.png", "w": 67, "h": 60}],
            "class": "drag-custom-oCcuAXGZRe",
            "hint": "",
        },
        {
            "coordinates": {"x": 724, "y": 129, "w": 67, "h": 60},
            "content": [{"image": "/static/SYSANALYSIS_R_03_04_task_img_10.png", "w": 67, "h": 60}],
            "class": "drag-custom-oCcuAXGZRe",
            "hint": "",
        },

    ],
    "settings": {
        "show_incorrect": True,
        "check_type": "partially",  # "partially", "full", "full_cell", "sequence"
        "capacity": 1,
    }
}


student_data = source_data.copy()
student_data["answers"] = []
student_data["all_answers"] = []
correct_answer = {}

for drop in source_data["answers"]:
    drop_id = generate_id()
    correct_answer[drop_id] = []
    drop_element = drop.copy()
    drop_element["id"] = drop_id
    del drop_element["content"]
    student_data["answers"].append(drop_element)

    for drag in drop["content"]:
        drag_id = generate_id()
        if 'id' in drag.keys():
            drag_id = drag['id']
        drag_element = drag.copy()
        drag_element["id"] = drag_id
        correct_answer[drop_id].append(drag_id)
        student_data["all_answers"].append(drag_element)
if 'distractors' in source_data.keys():
    for distractor in source_data['distractors']:
        distractor_element = distractor.copy()
        distractor_element["id"] = generate_id()
        student_data["all_answers"].append(distractor_element)

def check_partially(c_a, s_a):
    local_grade = 0
    local_incorrect = []
    for item in c_a.keys():
        for ans in c_a[item]:
            if ans in s_a[item]:
                local_grade += 1
        if sorted(s_a[item]) != sorted(c_a[item]):
            local_incorrect.append(item)
    return local_grade, local_incorrect


def check_full(c_a, s_a):
    local_grade = 1
    local_incorrect = []
    for item in c_a.keys():
        if sorted(s_a[item]) != sorted(c_a[item]):
            local_grade = 0
            local_incorrect.append(item)
    return local_grade, local_incorrect


def check_full_cell(c_a, s_a):
    local_grade = 0
    local_incorrect = []
    for item in c_a.keys():
        if sorted(s_a[item]) == sorted(c_a[item]):
            local_grade += 1
        else:
            local_incorrect.append(item)
    return local_grade, local_incorrect


def check_sequence(c_a, s_a):
    local_grade = 0
    local_incorrect = []
    for item in c_a.keys():
        if s_a[item] == c_a[item]:
            local_grade += 1
        else:
            local_incorrect.append(item)
    return local_grade, local_incorrect


def get_ok(grade_decimal):
    if grade_decimal == 1:
        return True
    elif grade_decimal == 0:
        return False
    else:
        return 'Partial'


def check_answer(expect, ans):
    student_answer = json.loads(ans)["answer"]
    max_grade = len(correct_answer.keys())
    if 'max_grade' in source_data["settings"]:
        max_grade = source_data["settings"]["max_grade"]
    check_types = ["partially", "full", "full_cell", "sequence"]
    check_type = "partially"
    if "check_type" in source_data["settings"].keys():
        if source_data["settings"]["check_type"] in check_types:
            check_type = source_data["settings"]["check_type"]

    grade = 0
    incorrect_answers = []
    if check_type == "full_cell":
        grade, incorrect_answers = check_full_cell(correct_answer, student_answer)
    elif check_type == "full":
        max_grade = 1
        grade, incorrect_answers = check_full(correct_answer, student_answer)
    elif check_type == "partially":
        max_grade = sum([len(correct_answer[x]) for x in correct_answer.keys()])
        grade, incorrect_answers = check_partially(correct_answer, student_answer)
    elif check_type == "sequence":
        grade, incorrect_answers = check_sequence(correct_answer, student_answer)
    else:
        pass

    result_grade = float(grade/max_grade)
    msg_json = {
        "incorrect_answers": incorrect_answers if source_data["settings"]["show_incorrect"] else []
    }

    return {
        'input_list': [
            {
                'ok': get_ok(result_grade),
                'msg': json.dumps(msg_json),
                'grade_decimal': result_grade
            },
        ]
    }


correct_data = json.dumps(source_data)
correct_data = correct_data.replace('"', "'")

random.shuffle(student_data["all_answers"])
student_data = json.dumps(student_data)
student_data = student_data.replace('"', "'")
</script>
</problem>
<p><strong>Пример</strong>. Дана задача оптимизации одной переменной, построенная на основе функции Растригина (рис. 1):</p>
\[ f(x) = x^2 - cos(2 \pi x) + 1 \to min \tag{1} \]
\[ -3 \le x \le 3  \tag{2} \]
<p>где \(f\) – целевая функция, \(x\) – управляемая переменная. Нужно найти такое значение \(x\), которое удовлетворяет условию \((2)\), и при котором функция \((1)\) достигает глобального минимума.</p>
<p>Рис.1. Функция со множеством локальных экстремумов</p>

<figure style="text-align:center;">
    <img src="/static/SYSANALYSIS_R_02_06_img_01.png" alt="" style="max-width: 600px;"/>
    <figcaption>Рис.1. Функция со множеством локальных экстремумов</figcaption>
</figure>
<p></p>

<p><strong>Решение</strong></p>
<p>Численно найти экстремум функции можно с помощью алгоритма роя частиц (Particle Swarm Optimization, PSO). Алгоритм реализован в большом количестве библиотек на различных языках программирования. Ниже приведен пример использования библиотеки PySwarms на языке Python. Представленный код можно вставить и запустить в среде Google Colab. В первую ячейку нужно поместить код для установки и подключения библиотек:</p>

<pre><code>!pip install pyswarms
import numpy as np
from pyswarms.single.global_best import GlobalBestPSO</code></pre>

<p>Во вторую код, содержащий оптимизируемую функцию и код для применения алгоритма роя части:</p>

<pre><code># функция, минимум которой нужно найти
def f1(x):
  return x[:, 0] ** 2 - np.cos(2 * np.pi * x[:, 0]) + 1

# пример функции одной переменной, поэтому размерность задачи равна единице
dimensions=1

# задаем область допустимых значений
x_max = 3 * np.ones(1) # можно записать x_max = [3]
x_min = -1 * x_max  # можно записать x_max = [-3]
bounds = (x_min, x_max)

# создание объекта, выполняющего оптимизацию
pso = GlobalBestPSO(n_particles=20, dimensions=dimensions, bounds=bounds, options = {'c1': 0.5, 'c2': 0.3, 'w':0.9})

# запуск оптимизации, указывается функция и число итераций
value_optimal, x_optimal = pso.optimize(f1, 100)

# вывод найденного решения
for i, x in enumerate(x_optimal):
  print('X[{0}]* = {1:.5f}'.format(i, x))
print('f(X*) = {0:.5f}'.format(value_optimal))</code></pre>


<p>Затем нужно запустить ячейки с кодом на выполнение или нажать <code class="inline">Ctrl+9</code>. Будет найдено близкое к нулю решение, так как алгоритм роя частиц решает задачу приближенно.</p>
<p>Для решения задачи оптимизации нескольких переменных нужно использовать индексы: \(x[:, 0], \ x[:, 1], \ x[:, 2]\), &hellip; в целевой функции; а вектор для определения границ, например в случае системы ограничений</p>
\[ -1 \le x_1 \le 3 \tag{3}\]
\[ 0 \le x_2 \le 4 \tag{4} \]
\[ 2 \le x_3 \le 5 \tag{5} \]
<p>можно записать:</p>
<p>\(x_{max} = [3, 4, 2]\)</p>
<p>\(x_{max} = [-1, 0, 5]\)</p>
<p>\(bounds = (x_{min}, x_{max})\)</p>
<p>Чем выше число частиц (<code class="inline">n_particles</code>) и число итераций (второй аргумент в функции <code class="inline">optimize</code>), тем дольше будет выполняться оптимизация, но тем выше точность полученного ответа с точки зрения близости к глобальном экстремуму целевой функции.</p>